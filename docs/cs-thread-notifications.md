# Thread Notifications

## Overview

The CXone SDK includes a feature that allows users to receive notifications about new messages in threads they're not currently viewing. When a user taps on these notifications, they should be directed to the relevant conversation.

The SDK supports both:
- **Local notifications**: Generated by the UI module when the app is in the foreground but the user is not viewing the thread where a message arrived
- **Remote (push) notifications**: Delivered by APNs when the app is in the background or not running

⚠️ Warning: Local notifications are only handled with the UI module. If you are only using the SDK, you must implement the mechanism yourself.

## Implementation Requirements

While the UI module handles most of this functionality internally, your application needs to implement:

1. Request notification permissions
2. Set up notification delegate and handle presentation
3. Register device token for push notifications
4. Process notification taps (for both local and remote notifications)

## Implementation Guide

### 1. Request Notification Permissions

Request permission to show notifications when your app launches:

```swift
func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
) -> Bool {
    // Set notification delegate
    UNUserNotificationCenter.current().delegate = self
    
    // Request notification permissions
    UNUserNotificationCenter.current().requestAuthorization(
        options: [.alert, .badge, .sound]
    ) { granted, error in
        if granted {
            DispatchQueue.main.async {
                UIApplication.shared.registerForRemoteNotifications()
            }
        }
    }
    
    return true
}
```

### 2. Implement UNUserNotificationCenterDelegate

Add notification handling by implementing `UNUserNotificationCenterDelegate` to handle both local and remote notifications:

```swift
extension AppDelegate: UNUserNotificationCenterDelegate {
    // Handle both local and remote notifications when app is in foreground
    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        willPresent notification: UNNotification
    ) async -> UNNotificationPresentationOptions {
        let identifier = notification.request.identifier
        let userInfo = notification.request.content.userInfo
        
        // Show remote push notification when chat is not available
        if !CXoneChat.shared.state.isChatAvailable {
            return [.list, .banner, .badge, .sound]
        }
        // Show local push notification when chat is available and it's a thread notification
        else if CXoneChat.shared.state.isChatAvailable && 
                identifier.hasPrefix(NotificationCenter.threadDeeplinkNotificationName) {
            return [.list, .banner, .badge, .sound]
        }
        
        return []
    }
    
    // Handle notification taps for both local and remote notifications
    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        didReceive response: UNNotificationResponse
    ) async {
        // Reset badge count
        UIApplication.shared.applicationIconBadgeNumber = 0
        
        // Process thread notification (works for both local and remote notifications)
        processNotificationAndNavigateToThread(notification: response.notification)
    }
}
```

### 3. Register Device Token for Remote Notifications

When your app successfully registers for remote notifications, you need to pass the device token to the SDK:

```swift
func application(
    _ application: UIApplication, 
    didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data
) {
    // 3. Pass the device token to the SDK
    // This allows the SDK to register the device for push notifications
    // with CXone's notification service
    CXoneChat.shared.customer.setDeviceToken(deviceToken)
}
```

### 4. Process Thread Notifications (Local and Remote)

Implement a method to process both local and remote thread notifications:

```swift
private func processNotificationAndNavigateToThread(notification: UNNotification) -> Bool {
    let userInfo = notification.request.content.userInfo
    
    // 4. Process thread notification
    // This method handles both notification types:
    // - Local notifications created by the SDK (with identifier prefix)
    // - Remote notifications from APNs (with threadId in payload)
    
    // Check for local notification from SDK first
    let identifier = notification.request.identifier
    if identifier.hasPrefix(NotificationCenter.threadDeeplinkNotificationName) {
        guard let threadIdString = userInfo["threadId"] as? String,
              let threadId = UUID(uuidString: threadIdString) else {
            return false
        }
        
        // Navigate to thread
        NotificationCenter.default.postThreadDeeplinkNotification(threadId: threadId)
        return true
    }
    
    // Check for remote notification from APNs
    // NOTE: The exact structure of remote notification payloads may vary
    // The implementation below is conceptual and should be adjusted to match
    // your actual server payload structure
    if let aps = userInfo["aps"] as? [String: Any],
       let cxoneData = userInfo["cxone_data"] as? [String: Any],
       let threadIdString = cxoneData["thread_id"] as? String,
       let threadId = UUID(uuidString: threadIdString) {
        
        // Navigate to thread using the same mechanism
        NotificationCenter.default.postThreadDeeplinkNotification(threadId: threadId)
        return true
    }
    
    return false
}
```

> **Note:** This method handles both local notifications generated by the SDK for hidden thread messages and remote notifications from APNs, as long as the remote notification payload includes the same `threadId` field. Ensure your remote notification payload matches this structure to enable navigation for remote notifications as well.

## Remote Push Notification Structure

For remote notifications to work with the SDK, they need to have a payload structure that includes the thread ID. The example below is conceptual and the actual structure may vary depending on your server implementation:

```json
{
  "aps": {
    "alert": {
      "title": "New Message",
      "body": "You have a new message in your conversation"
    },
    "badge": 1,
    "sound": "default"
  },
  "cxone_data": {
    "thread_id": "550e8400-e29b-41d4-a716-446655440000",
    "type": "thread_message"
  }
}
```

## How It Works

### Local Notifications

1. **Notification Creation**: When a message arrives in a thread the user isn't viewing (but the app is active), the UI module creates a local notification.

2. **Notification Display**: Your app's delegate methods control how the notification appears.

3. **User Interaction**: When the user taps the notification, your app extracts the thread ID and broadcasts a navigation event.

### Remote Push Notifications

1. **Token Registration**: The SDK registers the device token with CXone's notification service.

2. **Push Delivery**: When a message arrives in a thread and the app is not active, CXone's service sends a push notification via APNs.

3. **Notification Handling**: When your app launches from the notification tap, you extract the thread ID from the payload and navigate to the thread.

4. **Navigation**: Both notification types use the same navigation mechanism (`postThreadDeeplinkNotification`).

## Testing

### Local Notifications
1. Start a conversation in one thread
2. Have an agent send a message to a different thread while the app is open
3. Verify a notification appears
4. Tap the notification
5. Verify you're taken to the correct conversation

### Remote Notifications
1. Set up your backend to send push notifications with the correct payload format
2. Close your app
3. Have an agent send a message to a thread
4. Verify a push notification arrives on your device
5. Tap the notification
6. Verify the app opens and navigates to the correct conversation 
